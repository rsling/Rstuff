require(lme4)

rm(list = ls())
#set.seed(6226)   # date +%s%N | md5sum | tr -dC '[^0-9]' | cut -c1-4

# Units = Groups 
#                counter:     i
#                intercept:   alpha_i
#                slope:       beta_i
#
# Measurements  counter:       j
#
# Fixeff measurements:         x_ij.
#
# Responses:                   y_ij

###### GROUPS (or UNITS) ######

N <- 30  #  Number of groups.


# Generate the random intercepts and slopes
library(mvtnorm)

q = 0.2  # Intercept SD.
r = 0.9  # Intcp-Slope Covariance.
s = 0.5  # Slope SD.

# Based on our choices of qq and ss above, slopes vary more than intercepts.
# Also we've specified a correlation of 0.9 (i.e., 0.09/√[0.04∗0.25] or r*q*s),
# so when the intercept's random effect is above its mean (of zero),
# the same is likely true for the slope.

cov.matrix <-  matrix(c(q^2, r * q * s, r * q * s, s^2), nrow = 2, byrow = TRUE)
random.effects <-  rmvnorm(N, mean = c(0, 0), sigma = cov.matrix)

# In other words:
#
#   ⎛  q^2   r*q*s  ⎞
#   ⎝  r*q*s   s^2  ⎠
#

# Create random effects.
unit.df = data.frame(unit = c(1:N))
unit.df$alpha <- random.effects[, 1]
unit.df$beta  <- random.effects[, 2]


###### MEASUREMENTS (or INDIVIDUALS) ######


J = 100     # Number of obs. per GROUP
M = J * N  # Total number of observations.

# Within each group, x values are perfectly the same. WHY?
x.grid = seq(-4, 4, by = 8/J)[0:J]
within.unit.df <-  data.frame(
  unit = sort(rep(c(1:N), J)),
  j    = rep(c(1:J), N),
  x    = rep(x.grid, N)
  )

# Create full data frame with y values (with some standard normal epsilon).
# Note that alpha and beta are generated by the second-leve model
# PLUS random between-group variance.
flat.df <- merge(unit.df, within.unit.df)  # natural join using "unit"
flat.df <- within(flat.df, y <- alpha + x * beta + 0.75 * rnorm(n = M))

# Reduce to information we would have in actual experiment.
simple.df <-  flat.df[, c("unit", "x", "y")]

# Calculate random effects model.
# This is how it is done in lmer, see Gelman & Hill (2007:303ff).
raneff.lmer <-  lmer(y ~ x + (1 + x | unit), data = simple.df)
print(summary(raneff.lmer))
# 
# # Compare with simple LM, ignoring random effects.
# fixeff.lm <-  lm(y ~ x , data = simple.df)
# print(summary(fixeff.lm))
# 
# par(mfrow=c(2,2))
# plot(fixeff.lm)
# par(mfrow=c(1,1))
# 
# plot(raneff.lmer)
# 
# 

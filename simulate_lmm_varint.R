require(lme4)

rm(list = ls())
set.seed(5086)


N <- 30  #  Number of groups.
q = 0.2  # Intercept SD.

random.effects <-  rnorm(N, mean = c(0, 0))

# Create random effects.
unit.df = data.frame(unit = c(1:N))
unit.df$alpha <- random.effects


###### MEASUREMENTS (or INDIVIDUALS) ######


J = 100     # Number of obs. per GROUP
M = J * N  # Total number of observations.

# Within each group, x values are perfectly the same. WHY?
x.grid = seq(-4, 4, by = 8/J)[0:J]
within.unit.df <-  data.frame(
  unit = sort(rep(c(1:N), J)),
  j    = rep(c(1:J), N),
  x    = rep(x.grid, N)
  )

# Create full data frame with y values (with some standard normal epsilon).
# Note that alpha and beta are generated by the second-leve model
# PLUS random between-group variance.
flat.df <- merge(unit.df, within.unit.df)  # natural join using "unit"
flat.df <- within(flat.df, y <- alpha + x + 0.75 * rnorm(n = M))

# Reduce to information we would have in actual experiment.
simple.df <-  flat.df[, c("unit", "x", "y")]

# Calculate random effects model.
# This is how it is done in lmer, see Gelman & Hill (2007:303ff).
raneff.lmer <-  lmer(y ~ x + (1 | unit), data = simple.df)
print(summary(raneff.lmer))

# Compare with simple LM, ignoring random effects.
fixeff.lm <-  lm(y ~ x , data = simple.df)
print(summary(fixeff.lm))

par(mfrow=c(2,2))
plot(fixeff.lm)
par(mfrow=c(1,1))

plot(raneff.lmer)


